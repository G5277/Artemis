# artemis_hf_api.py
import streamlit as st
import os, json, docx, PyPDF2, re
from dotenv import load_dotenv
from huggingface_hub import InferenceClient

# -------------------
# Load environment variables
# -------------------
print("üîπ Loading environment variables...")
load_dotenv()

st.set_page_config(page_title="Artemis - Free Online Career Assistant", layout="wide")
st.title("üöÄ Artemis - Free Online Career Assistant")

# -------------------
# Get HF API key
# -------------------
HF_API_KEY = os.getenv("HF_API_KEY")
print(f"üîπ HF_API_KEY found: {'YES' if HF_API_KEY else 'NO'}")

if not HF_API_KEY:
    st.error("‚ùå Hugging Face API key not found. Please set it in your .env file.")

# HuggingFace client
client = InferenceClient(api_key=HF_API_KEY)
MODEL_ID = "HuggingFaceTB/SmolLM3-3B"
print(f"üîπ Using model: {MODEL_ID}")

# -------------------
# Inputs
# -------------------
company_name = st.text_input("Company Name")
job_description = st.text_area("Job Description")

# -------------------
# Resume upload
# -------------------
uploaded_file = st.file_uploader("Upload Candidate Resume (PDF or DOCX)", type=["pdf", "docx"])
resume_text = ""

if uploaded_file:
    print(f"üîπ Uploaded file type: {uploaded_file.type}")
    if uploaded_file.type == "application/pdf":
        pdf_reader = PyPDF2.PdfReader(uploaded_file)
        resume_text = "\n".join(
            page.extract_text() for page in pdf_reader.pages if page.extract_text()
        )
        print("üîπ Extracted text from PDF resume")
    elif uploaded_file.type == "application/vnd.openxmlformats-officedocument.wordprocessingml.document":
        doc = docx.Document(uploaded_file)
        resume_text = "\n".join([p.text for p in doc.paragraphs if p.text.strip()])
        print("üîπ Extracted text from DOCX resume")
    else:
        st.error("Unsupported file format!")
        print("‚ùå Unsupported file format")

# -------------------
# Helpers
# -------------------
def truncate_text(text: str, max_chars: int = 4000) -> str:
    return text[:max_chars] + ("..." if len(text) > max_chars else "")

# -------------------
# Enhanced JSON Schema for Resume Suggestions
# -------------------
STRICT_SCHEMA = {
    "type": "json_schema",
    "json_schema": {
        "name": "artemis_resume_output",
        "schema": {
            "type": "object",
            "additionalProperties": False,
            "properties": {
                "ResumeSuggestions": {
                    "type": "object",
                    "additionalProperties": False,
                    "properties": {
                        "Projects": {
                            "type": "array",
                            "items": {
                                "type": "object",
                                "properties": {
                                    "current": {"type": "string"},
                                    "change": {
                                        "type": "string",
                                        "maxLength": 120,
                                        "description": "Rewrite aligned with JD (‚â§20 words)."
                                    },
                                    "rationale": {
                                        "type": "string",
                                        "maxLength": 60,
                                        "description": "Why this improves ATS/clarity/impact."
                                    },
                                    "jd_alignment": {
                                        "type": "string",
                                        "maxLength": 80,
                                        "description": "Which JD skill/requirement this matches."
                                    }
                                },
                                "required": ["current", "change", "rationale", "jd_alignment"]
                            }
                        },
                        "Experience": {
                            "type": "array",
                            "items": {
                                "type": "object",
                                "properties": {
                                    "current": {"type": "string"},
                                    "change": {
                                        "type": "string",
                                        "maxLength": 120,
                                        "description": "Rewrite aligned with JD (‚â§20 words)."
                                    },
                                    "rationale": {
                                        "type": "string",
                                        "maxLength": 60,
                                        "description": "Why this improves ATS/clarity/impact."
                                    },
                                    "jd_alignment": {
                                        "type": "string",
                                        "maxLength": 80,
                                        "description": "Which JD skill/requirement this matches."
                                    }
                                },
                                "required": ["current", "change", "rationale", "jd_alignment"]
                            }
                        }
                    },
                    "required": ["Projects", "Experience"]
                },
                "CoverLetter": {"type": "string"},
                "Summary": {"type": "string"}
            },
            "required": ["ResumeSuggestions", "CoverLetter", "Summary"]
        }
    }
}


# -------------------
# Generate Suggestions
# -------------------
if st.button("Generate Suggestions"):
    print("üîπ Generate Suggestions button clicked")
    if not (company_name and job_description and resume_text):
        st.error("Please fill all fields and upload a resume!")
        print("‚ùå Missing input fields")
    else:
        with st.spinner("Generating suggestions online..."):
            print("üîπ Building prompt...")

            # -------------------
            # Prompt Template
            # -------------------
            prompt = f"""
You are An intelligent AI Resume assistant.
Your task is to improve the candidate's resume and provide a tailored cover letter + summary.

**Rules for ResumeSuggestions**:
- Output ONLY JSON (no prose).
- For each resume line:
  1. Keep the "current" text exactly as-is.
  2. Rewrite it in "change" so it highlights skills, tools, and metrics that are **directly relevant to the Job Description**.
- If something is irrelevant to the JD, suggest removing it ("change": "Remove - not aligned with JD").
- Always include "rationale" (‚â§60 chars) explaining why the change improves ATS/clarity/impact.
- Always include "jd_alignment" explaining which JD skill/requirement this change satisfies.
- Use strong action verbs, metrics, and ATS-friendly keywords.
- At least 3 tailored suggestions each for Projects and Experience (if content exists).

**Rules for CoverLetter**:
- Write a one-page, professional cover letter tailored to the company and role.
- Use a formal, confident, yet approachable tone (avoid clich√©s).
- Show clear alignment with the JD, referencing candidate‚Äôs relevant projects/experience.
- Highlight achievements with metrics and scope.
- Structure:
  1. Greeting + intent.
  2. How candidate skills/experience align with the JD.
  3. Why they want to join this company.
  4. Closing with call-to-action.

**Rules for Summary**:
- Write 1‚Äì2 lines maximum.
- Explain the overall rationale of the resume changes.
- Focus on *alignment with the JD*.

**Context**:
- Company: {company_name}
- Job Description (this must guide all tailoring): {truncate_text(job_description)}
- Candidate Resume: {truncate_text(resume_text)}

**Final Output Schema (STRICT)**:
{{
  "ResumeSuggestions": {{
    "Projects": [
      {{
        "current": "string",
        "change": "string (<20 words)",
        "rationale": "string (<60 chars)",
        "jd_alignment": "string (<80 chars)"
      }}, ...
    ],
    "Experience": [
      {{
        "current": "string",
        "change": "string (<20 words)",
        "rationale": "string (<60 chars)",
        "jd_alignment": "string (<80 chars)"
      }}, ...
    ]
  }},
  "CoverLetter": "string",
  "Summary": "string"
}}
"""


            parsed_output = None
            raw_output = ""

            # 1) Try strict JSON schema
            try:
                completion = client.chat.completions.create(
                    model=MODEL_ID,
                    messages=[{"role": "user", "content": prompt}],
                    max_tokens=1200,
                    response_format=STRICT_SCHEMA,
                )
                raw_output = completion.choices[0].message.content
                print("üîπ Raw model output (schema):", raw_output[:500], "...")
                parsed_output = json.loads(raw_output)
                print("üîπ Successfully parsed JSON output (schema)")
            except Exception as e:
                print(f"‚ö†Ô∏è Schema-enforced generation failed: {e}")

                # 2) Fallback to json_object
                if not parsed_output:
                    try:
                        completion = client.chat.completions.create(
                            model=MODEL_ID,
                            messages=[{"role": "user", "content": prompt}],
                            max_tokens=1200,
                            response_format={"type": "json_object"},
                        )
                        raw_output = completion.choices[0].message.content
                        print("üîπ Raw model output (json_object):", raw_output[:500], "...")
                        parsed_output = json.loads(raw_output)
                        print("üîπ Successfully parsed JSON output (json_object)")
                    except Exception as e2:
                        print(f"‚ö†Ô∏è Direct JSON parsing failed: {e2}")
                        # 3) Regex fallback
                        if raw_output:
                            match = re.search(r"\{.*\}", raw_output, re.DOTALL)
                            if match:
                                try:
                                    parsed_output = json.loads(match.group(0))
                                    print("üîπ Successfully extracted JSON via regex")
                                except Exception as e3:
                                    print(f"‚ùå Regex JSON parse failed: {e3}")

            # -------------------
            # Fallback for missing CoverLetter
            # -------------------
            if parsed_output and not parsed_output.get("CoverLetter"):
                try:
                    print("‚ö†Ô∏è CoverLetter missing, regenerating...")
                    cover_prompt = f"""
                    Write a professional one-page cover letter for:
                    - Candidate Resume: {truncate_text(resume_text, 3000)}
                    - Job Description: {truncate_text(job_description, 1500)}
                    - Company: {company_name}
                    Keep it ATS-friendly, concise, and aligned with the JD.
                    """
                    cover_completion = client.chat.completions.create(
                        model=MODEL_ID,
                        messages=[{"role": "user", "content": cover_prompt}],
                        max_tokens=600
                    )
                    parsed_output["CoverLetter"] = cover_completion.choices[0].message.content.strip()
                except Exception as e4:
                    print(f"‚ùå Fallback CoverLetter generation failed: {e4}")

            # -------------------
            # Display
            # -------------------
            if not parsed_output:
                st.warning("‚ö†Ô∏è Could not parse as JSON. Showing raw output:")
                st.code(raw_output if raw_output else "No output")
            else:
                st.success("Suggestions Generated ‚úÖ")

                with st.expander("üîç Raw JSON Preview"):
                    st.code(json.dumps(parsed_output, indent=2))

                # Resume Suggestions
                with st.expander("üìÑ Resume Suggestions", expanded=True):
                    def render_section(title: str, items: list):
                        st.subheader(title)
                        if not items:
                            st.write("- No suggestions.")
                            return
                        for item in items:
                            current = item.get("current", "").strip()
                            change = item.get("change", "").strip()
                            rationale = item.get("rationale", "").strip()
                            if current:
                                st.write(f"‚û°Ô∏è **{current}**")
                            if change:
                                st.write(f"üîπ **Change:** {change}")
                            if rationale:
                                st.caption(f"üí° {rationale}")
                            st.markdown("---")

                    rs = parsed_output.get("ResumeSuggestions", {})
                    render_section("Projects", rs.get("Projects", []))
                    render_section("Experience", rs.get("Experience", []))

                # Cover Letter
                with st.expander("‚úâÔ∏è Generated Cover Letter"):
                    st.write(parsed_output.get("CoverLetter", ""))

                # Summary
                with st.expander("üìù Summary / Feedback"):
                    st.write(parsed_output.get("Summary", ""))
